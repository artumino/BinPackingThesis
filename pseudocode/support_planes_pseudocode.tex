\documentclass{article}
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\begin{document}

\begin{algorithmic}
    \Function{3DBPP}{$items$, $W$, $H$, $D$}
        \State $bins \gets \emptyset$;
        \State $items \gets items \cup \Call{generateSuperItems}{items}$;
        \Repeat
            \State $packedItems \gets \Call{packBin}{items, W, H, D}$ ;
            \State $bin \gets \Call{completeBin}{packedItems, W, H, D}$;
            \State $bins \gets bins \cup bin$; 
            \State $items \gets items \setminus packedItems$;
        \Until{$items = \emptyset$};
        \State \Return $bins$;
    \EndFunction
    \vspace{1cm}

    \Function{packBin}{$items$, $W$, $H$, $D$}
        \State $packed \gets \emptyset$;
        \State $currentPacking \gets \emptyset$;
        \State $toPack \gets items$;
        \State $planes \gets \{ (0, \emptyset, \emptyset) \}$; \Comment PriorityQueue, (z, supportItems, upperItems)
        \Repeat
            \State $p \gets $ \Call{dequeue}{$planes$}; \Comment Polls the lowest plane from the set
            \State $currentPacking \gets \Call{packPlane}{p, toPack, W, H, D}$;
            \State $packed \gets packed \cup currentPacking$;
            \State $toPack \gets toPack \setminus packed$;
            \State $\Call{updatePlanes}{planes, currentPacking, 5}$;
        \Until{$planes = \emptyset \vee toPack = \emptyset \vee currentPacking = \emptyset$};
        \State \Return $packed$;
    \EndFunction
    \vspace{1cm}

    \Procedure{updatePlanes}{$planes$, $packed$, $tolerance$}
        \For{$item$ in $packed$}
            \If{$\not\exists p \in planes: |p.z - item.z| \le tolerance$}
                \State $planes \gets planes \cup (item.z, \emptyset, \emptyset)$;
            \EndIf
            \For{$p \in planes: 0 \le p.z - (item.z + item.w) \le tolerance$}
                \State $p.supportItems \gets p.supportItems \cup item$;
            \EndFor
            \For{$p \in planes: p.z < (item.z + item.w)$}
                \State $p.upperItems \gets p.upperItems \cup item$;
            \EndFor
        \EndFor
    \EndProcedure
    \newpage

    \Function{packPlane}{$plane$, $toPack$, $W$, $H$, $D$}
        \State $packed \gets \emptyset$;
        \Repeat
            \State $bestScore \gets 0$;
            \State $bestPacking \gets null$;
            \For{$item \in toPack: plane.z + item.z \le H$}
                \State $packing \gets \Call{2DBPPwithObstacles}{item, packed, plane, W, H, D}$;
                \State $score \gets \Call{scorePacking}{packed \cup packing, W, H, D}$;
                \If{$score > bestScore$}
                    \State $bestScore \gets score$;
                    \State $bestPacking \gets packing$;
                \EndIf
            \EndFor
            \State $packed \gets packed \cup bestPacking$;
            \State $toPack \gets toPack \setminus bestPacking$;
        \Until{$toPack = \emptyset \vee bestPacking = null$};
        \State \Return $packed$;
    \EndFunction
    \vspace{1cm}

    \Function{scorePacking}{$packed$, $W$, $H$, $D$}
        \State $A \gets \Call{sumArea}{packed}$;
        \State $V \gets \Call{sumVolume}{packed}$;
        \State \Return $A + V$;
    \EndFunction
\end{algorithmic}


\end{document}