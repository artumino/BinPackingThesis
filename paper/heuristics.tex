In this chapter we describe a solution to the 3D bin packing problem with static stability.
A solution candidate to the problem can be found by conducting a search over the graph of possible packings or states given an approriate rappresentation which is described in section \ref{sec:problem_state}.
Since an exaustive search isn't feasible, an heuristic search is conducted by combining a beam search algorithm described in section \ref{sec:beamsearch} and constructive heuristic described in section \ref{sec:support_planes}.
The proposed algorithm takes in input an initial feasible state (as defined in section \ref{sec:problem_state:feasibility}) usually rappresented by the empty state (\ref{def:empty_state}) and outputs the best scoring state based on an ordering function defined in section \ref{ssec:scoring_states}.

\section{State}
\label{sec:problem_state}%
States or packings are partial solutions to the 3DBPP. Given the formal definition of the problem (\ref{sec:milp}) a few new definitions are introduced to facilitate the algorithm's definition.
\begin{definition}[Unpacked item]
    Given an item $i \in I$ we define it as unpacked \textbf{iff}
    \begin{equation*}
        \sum_{b \in B} u_{ib} = 0
    \end{equation*}
\end{definition}
A state $s$ can then be defined as follows
\begin{itemize}
    \item $U$: the set of unpacked items
    \item $B$: the set of bins
    \item $(s_1, s_2,.., s_b)$: the set of supporting structures for each bin $b \in B$
\end{itemize}

\begin{observation}
    Given two states $s$ and $s^\prime$ we can have that $|s.B| \neq |s^\prime.B|$ since the number of bins is also a variable in the proposed heuristic
\end{observation}

Each bin $b$ has additional data used to facilitate the execution of the algorithm that is contained in $s_b$. 
Let us introduce the concept of placement inside a bin:
\begin{definition}[Packed item]
    Given a state $s$ and a bin $b \in s.B$, we say that item $i \in I$ is packed in $b$ \textbf{iff} 
    
    \begin{equation*}
        \left\{ 
            \begin{aligned}
                u_{ib} & = 1, \\
                \sum_{j \in s.B, j \neq b}{u_{ij}} & = 0
            \end{aligned}
        \right.
    \end{equation*}
\end{definition}
\subsection{Feasibility}
\label{sec:problem_state:feasibility}%

\begin{observation}
    \label{def:empty_state}
    We can always define the empty state $s_e$ where \begin{equation*}
        \left\{ 
            \begin{aligned}
            s_e.U & = I \\
            s_e.B & = \emptyset
            \end{aligned}
        \right.
    \end{equation*}
    and it is always feasible
\end{observation}

\section{Beam Search}
\label{sec:beamsearch}%
Beam Search (BS) %TODO: maybe add info on literature, define indices
is an heuristic graph search algorithm designed for systems with limited memory where expanding every possible node is unfeasible.
The idea behind BS is to conduct a iterative truncated breadth-first search where, at each iteration, expanded nodes are ranked based on an heuristic and only the best ones are further explored.
To perform BS one must define the node structure, an expansion function to generate new nodes from an existing one, an evaluation function to compare nodes between eachother and a function to determine if a node is a solution to the problem.

%TODO

Let $s_i$ be a node in the graph of possible solutions of the 3DBPP, %todo change to group by height
$s_i$ can be seen as an instance of the problem where a sequence of placements has taken place.
An expansion of a node $s_i$ generates a new node $s_j$ where a placement has occured for a given set of items.
Since evaluating possible expansions can be computationally easier than computing new node data structures, %TODO: Explain better
a $Commit$ function is defined which applies a pre-computed expansion by updating the supporting data structures in its node.

Given $S_{init}$ the set of initial nodes to start from and $k$ the number of best nodes to expand at each iteration, the described procedure is rappresented by algorithm \ref{algo:beamsearch}.

\input{algorithms/beamsearch}

The $Expand$ function computes new nodes which rappresent possible placements that can be made starting from a given packing.
Each node contains a number of supporting data structures that are updated across iterations by the $Commit$ function.

Let $S$ be the set of nodes that need to be expanded, each node $s$ is rappresented by a structure which contains
\begin{itemize}
    \item[--] $bins$: the set of open bins
    \item[--] $unpacked$: the set of items that aren't assigned to any bin
    \item[--] $s_b$: a substructure which cointains informations about a bin $b$
\end{itemize}
%TODO: espandere GroupByHeight
Let $GroupByHeight(I)$ be a function which operates on a set of items and outputs a set of tuples $(t, I)$ where $t$ is the family of the set $I$ of items. %TODO: Explain better
A new set of nodes can be computed by using an underlying 3DSPP heuristic which evaluates the best move for each family of items for each currently opened bin.
The described procedure is detailed in algorithm \ref{algo:state_successor}  

\input{algorithms/state_successor}

\subsection{Scoring States}
\label{ssec:scoring_states}%
In order to sort nodes, a scoring function needs to be defined over the nodes. 
To allow the BS to explore better solutions the scoring function can't be as flat as the objective function defined in the mathematical formulation of the problem. %TODO: aggiungere ref

\section{Support Planes}
\label{sec:support_planes}%
%TODO far scorrere meglio
We introduce Support Planes (SP) which is an heuristic introduced in this thesis based on an underlying 2DBPP heuristic which is used to evaluate feasible expansions of a given node in the BS.
The proposed heuristic ensures that the constraint of support isn't violated.
The idea at the base of SP is to build a solution to the 3DSPP by filling 2D planes called support planes.

Each support plane can be characterized by the triple $S_z = (z, I_{support}, I_{upper})$ where
\begin{itemize}
    \item[--] $z$: the height of the plane 
    \item[--] $I_{support}$: the set of the items that can offer support to items placed on the plane
    \item[--] $I_{upper}$: the set of items that will be obstacles to potential new items placed on the plane %TODO: change explaination to be more faithfull to the algorithm
\end{itemize}%TODO: link to support

Let $s_b$ be a data structure containing
%TODO: Weight? Forbidden Cuts?
\begin{itemize}
    \item[--] $planes$: the set of triples $S_z$ of support planes to evaluate, ordered in ascending $z$ order
    \item[--] $aabb$: the AABB Tree of the items placed in the evaluated bin
    \item[--] $(W_{b}, D_{b}, H_{b})$: the dimensions of the bin
\end{itemize}

Let $coords$ be the set of possible coordinate changes which allow for the problem to evaluate placements starting from different corners of the bin. %TODO: leave this here?
%TODO: Maybe explicit rotation?

Given a function $IsFeasible(i, bin, I_{support}, I_{upper}, aabb)$ which evaluates if a packing of item $i$ in bin $bin$ is feasible,
and the function $ComparePacking(p, p^\prime)$ which defines a ranking over placements in the same plane,
the SP algorithm can be written as algorithm \ref{algo:sp_bestinsertion}.
%TODO: Too many "let"?

\input{algorithms/supportplane}

To evaluate a packing on a plane an heuristic to solve the 2DBPP is used with the introduction of fixed placements which rappresent items on other planes that will be obstacles in the current one.

%TODO: Specify that the selected heuristic must operate with the assumption of fixed placements

Given the dimensions of the 2D bin $(W_b, D_b)$, the set of obstacles $I_{o}$ and the set of items to pack $I_{p}$ a new placement can be computed following algorithm \ref{algo:sp_rectpack}

\input{algorithms/sp_rectpack}

Once the $k$ best nodes are selected the placements evaluated for each node are applied and the $Commit$ function updates every datastructure in $S$, including the ones used by SP.
Given the instance that generated one of the placements selected and $p$ the current set of support planes, $z_{min}$ the minimum $z$ coordinate for which a placement was made in the related bin starting from the current state, $I$ the set of items placed, $U$ the set of items unpacked.
Since placements are evaluated in order starting from the lower $z$ possible, if no placement was made in an open support plane with $z$ lower than $z_{min}$, the plane can be pruned to avoid further evaluations.
The algorithm which updates the structures for a given SP instance is rappresent by algorithm \ref{algo:sp_commit}.

\input{algorithms/sp_commit}

\subsection{Scoring Insertions}

\section{Max Rects}\label{chapter:heuristics:maxrects}

\subsection{AABB Tree}\label{sec:aabbtree}

In order to check the feasibility of a given insertion,
a way of checking for intersections is needed.
Since every box in a solution is axis aligned and defined by a static bounding box an Axis Aligned Bounding Box Tree (AABB Tree) is constructed and updated throughout the various nodes of the search.
AABB Trees are accelleration structures which allow the computation of intersections given a bounding box with a time complexity of $O(\log{n})$ where $n$ is the number of items placed.
