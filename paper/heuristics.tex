In this chapter we describe a solution to the 3D bin packing problem with static stability.
A solution candidate to the problem can be found by conducting a search over the tree of possible packings or states. In section \ref{sec:problem_state} we describe what a state or packing is and its rappresentation.
Since an exaustive search isn't feasible, an heuristic search is conducted by combining a beam search algorithm described in section \ref{sec:beamsearch} and constructive heuristic described in section \ref{sec:support_planes}.
The proposed algorithm takes in input an initial feasible state (as defined in section \ref{sec:problem_state:feasibility}) usually rappresented by the empty state (\ref{def:empty_state}) and outputs the best scoring state based on an ordering function defined in section \ref{ssec:scoring_states}.

\section{State}
\label{sec:problem_state}%
States or packings are partial solutions to the 3DBPP. Given the formal definition of the problem (\ref{sec:milp}) a few new definitions are introduced to facilitate the algorithm's definition.
\begin{definition}[Unpacked item]
    Given an item $i \in I$ we define it as unpacked \textbf{iff}
    \begin{equation*}
        \sum_{b \in B} u_{ib} = 0
    \end{equation*}
\end{definition}

It is also assumed that variables identifing an item are independent between states.

A state $s$ can then be defined as follows
\begin{itemize}
    \item $U$: the set of unpacked items
    \item $B$: the set of bins
    \item $(s_1, s_2,\dots, s_b)$: the set of supporting structures for each bin $b \in B$
    \item $p$: the insertion pending on this state (described by def. \ref{def:insertion})
\end{itemize}

\begin{observation}
    Given two states $s$ and $s^\prime$ we can have that $|s.B| \neq |s^\prime.B|$ since the number of bins is also a variable in the proposed heuristic
\end{observation}

We can also trivially define a function which determines if a state is a final state
\begin{definition}
    \label{def:state_final}
    A state $s$ is final if there are no more items to pack
    \begin{equation}
        \label{algo:state_final}%
        IsFinal(s) = \left\{\begin{aligned}
            1,\hspace{0.5cm}& s.U = \emptyset \\
            0,\hspace{0.5cm}& \text{otherwhise}
        \end{aligned}
        \right.
    \end{equation}
\end{definition}

Each bin $b$ has additional data that is contained in a structure $s_b$ used to facilitate the execution of the algorithm. 

Let us introduce the concept of packed items inside a bin:
\begin{definition}[Packed item]
    Given a state $s$ and a bin $b \in s.B$, we say that item
    \begin{equation*}
        \begin{aligned}
            i \in I \hspace{.2cm}\text{is packed in} \hspace{.2cm}b \hspace{.2cm}& \textbf{iff} \hspace{.2cm}& \left\{ 
                \begin{aligned}
                    u_{ib} & = 1, \\
                    \sum_{j \in s.B, j \neq b}{u_{ij}} & = 0
                \end{aligned}
            \right.
        \end{aligned}
    \end{equation*}
\end{definition}

Given a bin $b \in s.B$ we can then define structure $s_b$ as follows
\begin{itemize}
    \item $J$: the set of items that are packed inside $b$
    \item $Z$: the set of planes inside $b$ (section \ref{sec:support_planes})
    \item $T$: the AABB Tree (section \ref{sec:problem_state:aabbtree}) rappresenting the items inside $b$
\end{itemize}

Notice that two separate sets containing the items packed in $b$ are present inside $s_b$ but adding and accessing items in $s_b.J$ has time complexity of $O(1)$ given an underlying implementation as hashset while mantaining $s_b.T$ usually has a time complexity of $O(log(|s_b.J|))$.

The reason to include an AABB Tree inside this structure is further explained in sections \ref{sec:problem_state:feasibility} and \ref{ssec:scoring_insertions}

\subsection{AABB Tree}
\label{sec:problem_state:aabbtree}%

In order to determine the feasibility of a given state, a way of checking for overlaps with items already placed is needed.
Since our formulation of the problem only allows for $90\deg$ rotations over the z-axis. Every item in a solution, by the problem formulation (\ref{fig:coordinate_system}), is contained inside a bounding box and this box is axis-aligned.
An adequate structure to compute overlaps is then an Axis-Aligned Bounding Box Tree (AABB Tree) \cite{bergen1997efficient}.

AABB Trees are a bounding volume hierarchies tipically used for fast collision detection and they usually offer a few operations:
\begin{itemize}
    \item $AABBInsert(i)$: which allows to insert an axis-aligned box $i$ in the tree
    \item $AABBOverlaps(i)$: which allows to determine if an axis-aligned box $i$ overlaps an element in the tree
    \item $AABBClosest(i, d)$: which given an axis-aligned box $i$ and a direction $d \in \{ XP, XN, YP, YN, ZP, ZN \}$ along an axis, returns the closest element inside the tree following that direction starting from the box $i$
    %TODO: Check this
\end{itemize}

If the tree is properly balanced each operation on avarage has a time complexity of $O(log(n))$ where $n$ is the number of elements in the tree.

Mantaining an AABB Tree in the state allows us to do checks for feasibility during the construction of a solution (as detailed in \ref{ssec:scoring_insertions} ) and feasibility checks on the final states to allow for error detection.

\subsection{Feasibility}
\label{sec:problem_state:feasibility}%
A state $s$ is said to be feasible if the currently packed items for every bin $b \in s.B$ respects the constraints defined in the problem formulation (\ref{sec:milp})

Since the proposed heuristic is constructive it is more convenient to define the concept of feasibility relative to a change in the state.

\paragraph*{Insertions}

Given a state $s$ and $b \in s.B$, an insertion of items is a set of items that are placed in $b$ and have their $z_i$ within tollerance of a certain $z$.

\begin{definition}[Insertion]
    \label{def:insertion}%
    Given a state $s$ and a tollerance $\beta_s$ we define an insertion or placement $p$ a tuple $(b, I)$ where $b$ is a bin and $I$ is a set of items that are going to be packed in $b$ such that, $I \subseteq s.U \land \exists z (z \in \mathbb{Z} \land \forall i ( i \in I \land |z_i - z| \le \beta_s))$
\end{definition}

\begin{observation}
    Given $s$ and $p = (b, \emptyset)$ where $b \notin s.B$, $p$ is an insertion which will open bin $b$ in $s$.
\end{observation}

\begin{definition}[Next]
    \label{def:state_next}%
    Let $p$ be an insertion over a state $s$ we can then define $s^\prime = Next(s, p)$ as the "copy" of state $s$ with $s^\prime.p = p$. And $p$ is then pending on $s^\prime$.
\end{definition}

In this way we can evaluate the changes to the score of a state based on its pending insertion without having to update all the structures for every evaluated state. This property will become apparent in section \ref{sec:beamsearch}. 

We can then define an algorithm that applies insertions to a given state $s$ with pending insertions with the help of a function $OpenBin(b)$ which initializes a new structure $s_b$ with every element at its empty value.
The proposed algorithm is shown in \ref{algo:state_commit}.

\input{algorithms/state_commit}

\paragraph*{Insertion feasibility}
Describe insertion feasibility givine the sets defined\\
\input{algorithms/insertion_feasible}
%TODO: Continue with definition of feasibility for sets already made and feasibility of an insertion

\paragraph*{State feasibility}
Describe how to compute the sets efficiently to use the insertion feasibility logic\\
\input{algorithms/state_feasible}
%TODO: Give a brief description on how to use the AABB to computer the feasibility of a given state instead

\begin{proposition}
    \label{prop:feasible_expansion}
    A state $s^\prime$ derived by committing a feasible insertion $p$ to a feasible state $s$ is feasible.
\end{proposition}
%TODO: Do I need to demonstrate this?

\begin{observation}
    \label{def:empty_state}
    We can always define the empty state $s_e$ where \begin{equation*}
        \left\{ 
            \begin{aligned}
            s_e.U & = I \\
            s_e.B & = \emptyset
            \end{aligned}
        \right.
    \end{equation*}
    and it is always feasible
\end{observation}

\section{Beam Search}
\label{sec:beamsearch}%
Beam Search (BS) %TODO: maybe add info on literature
is an heuristic tree search algorithm designed for systems with limited memory where expanding every possible node is unfeasible.
The idea behind BS is to conduct an iterative truncated breadth-first search where, at each iteration, only a limited number $k$ of nodes is expanded.
After the expansion every new node needs to be evaluated and sorted in order to prune the number of nodes down to the $k$ best ones. The algorithm keeps exploring until no further node can be expanded.

To perform BS one must define the node structure, an expansion function to generate new nodes from existing ones, a ranking between nodes and a function to determine if a node is final.

By using as a node the state in \cref{sec:problem_state} and \cref{algo:state_final} to define if a node is final we know that a new state $s^\prime$ derived by $s$ by applying a feasible insertion $p$ can be computed as in \cref{def:state_next}.
This node expansion procedure, with the exception of empty insertions, will generate new nodes in our tree which we can score and will add a strictly positive number of bins or packed items to the solution so eventually it will generate a final state.

Furthermore, if the starting state for the search is feasible every new state generated will be feasible and if a final state is found it will be feasible ( \cref{prop:feasible_expansion}).

We also note that starting from node $s$ the time complexity to compute feasible insertions can be lower than the complexity required to update the structures that will be used for further expansions (AABB Tree insertion and balancing, memory cloning, etc.) so we modified the standard BS algorithm to separate the expansion phase from the commit phase.

Given $S^0$ the set of initial states to start from and $k$ the number of best nodes to expand at each iteration, the described procedure is rappresented by algorithm \ref{algo:beamsearch}.

As observed in \cref{def:empty_state} it's possible to start the search from $S^0 = \{ s_e \}$.

\input{algorithms/beamsearch}

\paragraph*{Node Expansion}

An expansion of a state $s$ can be seen as a new set of nodes $S_{new}$ that is computed by a set of feasible insertions.
In order to determine these insertion an underlying heuristic is used (described in \cref{sec:support_planes}).

%TODO: Citation needed? Maybe search in martello, vigo
The main idea in this phase of the algorithm is to find feasible insertions in all the bins for items that still need to be packed and that are of the same height.
With this approach the solutions given by the algorithm will start by trying to fill layers with items of the same height if possible.

The underlying heuristic introduced will also use a scoring mechanism to select the best instertions for a given class of heights in order to avoid having too many states.

Given a set of items $I$ and a tollerance $\beta_s$ we can introduce an algorithm to group them by height and produce a set $G$ of tuples $(h, I^\prime)$ where $h$ is the height of the group and $I^\prime$ is the set of items grouped as \cref{algo:group_by_height}.

\input{algorithms/group_by_height}

The described procedure is detailed in algorithm \ref{algo:state_successor}  

\input{algorithms/state_successor}

\subsection{Scoring States}
\label{ssec:scoring_states}%
In order to sort states, a scoring function needs to be defined over them.
By observing the differences between states we note that we can  
To allow the BS to explore better solutions the scoring function can't be as flat as the objective function defined in the mathematical formulation of the problem. %TODO: aggiungere ref

\section{Support Planes}
\label{sec:support_planes}%
%TODO far scorrere meglio
We introduce Support Planes (SP) which is an heuristic introduced in this thesis based on an underlying 2DBPP heuristic which is used to evaluate feasible expansions of a given node in the BS.
The proposed heuristic ensures that the constraint of support isn't violated.
The idea at the base of SP is to build a solution to the 3DSPP by filling 2D planes called support planes.

Each support plane can be characterized by the triple $S_z = (z, I_{support}, I_{upper})$ where
\begin{itemize}
    \item[--] $z$: the height of the plane 
    \item[--] $I_{support}$: the set of the items that can offer support to items placed on the plane
    \item[--] $I_{upper}$: the set of items that will be obstacles to potential new items placed on the plane %TODO: change explaination to be more faithfull to the algorithm
\end{itemize}%TODO: link to support

Let $s_b$ be a data structure containing
%TODO: Weight? Forbidden Cuts?
\begin{itemize}
    \item[--] $planes$: the set of triples $S_z$ of support planes to evaluate, ordered in ascending $z$ order
    \item[--] $aabb$: the AABB Tree of the items placed in the evaluated bin
    \item[--] $(W_{b}, D_{b}, H_{b})$: the dimensions of the bin
\end{itemize}

Let $coords$ be the set of possible coordinate changes which allow for the problem to evaluate placements starting from different corners of the bin. %TODO: leave this here?
%TODO: Maybe explicit rotation?

Given a function $IsFeasible(i, bin, I_{support}, I_{upper}, aabb)$ which evaluates if a packing of item $i$ in bin $bin$ is feasible,
and the function $ComparePacking(p, p^\prime)$ which defines a ranking over placements in the same plane,
the SP algorithm can be written as algorithm \ref{algo:sp_bestinsertion}.
%TODO: Too many "let"?

\input{algorithms/supportplane}

To evaluate a packing on a plane an heuristic to solve the 2DBPP is used with the introduction of fixed placements which rappresent items on other planes that will be obstacles in the current one.

%TODO: Specify that the selected heuristic must operate with the assumption of fixed placements

Given the dimensions of the 2D bin $(W_b, D_b)$, the set of obstacles $I_{o}$ and the set of items to pack $I_{p}$ a new placement can be computed following algorithm \ref{algo:sp_rectpack}

\input{algorithms/sp_rectpack}

Once the $k$ best nodes are selected the placements evaluated for each node are applied and the $Commit$ function updates every datastructure in $S$, including the ones used by SP.
Given the instance that generated one of the placements selected and $p$ the current set of support planes, $z_{min}$ the minimum $z$ coordinate for which a placement was made in the related bin starting from the current state, $I$ the set of items placed, $U$ the set of items unpacked.
Since placements are evaluated in order starting from the lower $z$ possible, if no placement was made in an open support plane with $z$ lower than $z_{min}$, the plane can be pruned to avoid further evaluations.
The algorithm which updates the structures for a given SP instance is rappresent by algorithm \ref{algo:sp_commit}.

\input{algorithms/sp_commit}

\subsection{Scoring Insertions}
\label{ssec:scoring_insertions}%