In this chapter we describe a solution to the 3D bin packing problem with static stability.
A solution candidate to the problem can be found by conducting a search over the tree of possible packings or states. In section \ref{sec:problem_state} we describe what a state or packing is and its rappresentation.
Since an exaustive search isn't feasible, an heuristic search is conducted by combining a beam search algorithm described in section \ref{sec:beamsearch} and constructive heuristic described in section \ref{sec:support_planes}.
The proposed algorithm takes in input an initial feasible state (as defined in section \ref{sec:problem_state:feasibility}) usually rappresented by the empty state (\ref{def:empty_state}) and outputs the best scoring state based on an ordering function defined in section \ref{ssec:scoring_states}.

\section{State}
\label{sec:problem_state}%
States or packings are partial solutions to the 3DBPP. Given the formal definition of the problem (\ref{sec:milp}) a few new definitions are introduced to facilitate the algorithm's definition.
\begin{definition}[Unpacked item]
    Given an item $i \in I$ we define it as unpacked \textbf{iff}
    \begin{equation*}
        \sum_{b \in B} u_{ib} = 0
    \end{equation*}
\end{definition}

It is also assumed that variables identifing an item are independent between states.

A state $s$ can then be defined as follows
\begin{itemize}
    \item $U$: the set of unpacked items
    \item $B$: the set of bins
    \item $(s_1, s_2,\dots, s_b)$: the set of supporting structures for each bin $b \in B$
    \item $P$: the set of insertions pending on this state (described by def. \ref{def:insertion})
\end{itemize}

\begin{observation}
    Given two states $s$ and $s^\prime$ we can have that $|s.B| \neq |s^\prime.B|$ since the number of bins is also a variable in the proposed heuristic
\end{observation}

We can also trivially define a function which determines if a state is a final state
\begin{definition}
    A state $s$ is final if there are no more items to pack
    \begin{equation}
        \label{algo:state_final}%
        IsFinal(s) = \left\{\begin{aligned}
            1,\hspace{0.5cm}& s.U = \emptyset \\
            0,\hspace{0.5cm}& \text{otherwhise}
        \end{aligned}
        \right.
    \end{equation}
\end{definition}

Each bin $b$ has additional data that is contained in a structure $s_b$ used to facilitate the execution of the algorithm. 

Let us introduce the concept of packed items inside a bin:
\begin{definition}[Packed item]
    Given a state $s$ and a bin $b \in s.B$, we say that item
    \begin{equation*}
        \begin{aligned}
            i \in I \hspace{.2cm}\text{is packed in} \hspace{.2cm}b \hspace{.2cm}& \textbf{iff} \hspace{.2cm}& \left\{ 
                \begin{aligned}
                    u_{ib} & = 1, \\
                    \sum_{j \in s.B, j \neq b}{u_{ij}} & = 0
                \end{aligned}
            \right.
        \end{aligned}
    \end{equation*}
\end{definition}

Given a bin $b \in s.B$ we can then define structure $s_b$ as follows
\begin{itemize}
    \item $J$: the set of items that are packed inside $b$
    \item $Z$: the set of planes inside $b$ (section \ref{sec:support_planes})
    \item $T$: the AABB Tree (section \ref{sec:problem_state:aabbtree}) rappresenting the items inside $b$
\end{itemize}

Notice that two separate sets containing the items packed in $b$ are present inside $s_b$ but adding and accessing items in $s_b.J$ has time complexity of $O(1)$ given an underlying implementation as hashset while mantaining $s_b.T$ usually has a time complexity of $O(log(|s_b.J|))$.

The reason to include an AABB Tree inside this structure is further explained in sections \ref{sec:problem_state:feasibility} and \ref{ssec:scoring_insertions}

\subsection{AABB Tree}
\label{sec:problem_state:aabbtree}%

In order to determine the feasibility of a given state, a way of checking for overlaps with items already placed is needed.
Since our formulation of the problem only allows for $90\deg$ rotations over the z-axis. Every item in a solution, by the problem formulation (\ref{fig:coordinate_system}), is contained inside a bounding box and this box is axis-aligned.
An adequate structure to compute overlaps is then an Axis-Aligned Bounding Box Tree (AABB Tree) \cite{bergen1997efficient}.

AABB Trees are a bounding volume hierarchies tipically used for fast collision detection and they usually offer a few operations:
\begin{itemize}
    \item $AABBInsert(i)$: which allows to insert an axis-aligned box $i$ in the tree
    \item $AABBOverlaps(i)$: which allows to determine if an axis-aligned box $i$ overlaps an element in the tree
    \item $AABBClosest(i, d)$: which given an axis-aligned box $i$ and a direction $d \in \{ XP, XN, YP, YN, ZP, ZN \}$ along an axis, returns the closest element inside the tree following that direction starting from the box $i$
    %TODO: Check this
\end{itemize}

If the tree is properly balanced each operation on avarage has a time complexity of $O(log(n))$ where $n$ is the number of elements in the tree.

Mantaining an AABB Tree in the state allows us to do checks for feasibility during the construction of a solution (as detailed in \ref{ssec:scoring_insertions} ) and feasibility checks on the final states to allow for error detection.

\subsection{Feasibility}
\label{sec:problem_state:feasibility}%
A state $s$ is said to be feasible if the currently packed items for every bin $b \in s.B$ respects the constraints defined in the problem formulation (\ref{sec:milp})

Since the proposed heuristic is constructive it is more convenient to define the concept of feasibility relative to a change in the state.

\paragraph*{Insertions}

Given a state $s$ and $b \in s.B$, an insertion of items is a set of items that are placed in $b$ and have their $z_i$ within tollerance of a certain $z$.

\begin{definition}[Insertion]
    \label{def:insertion}%
    Given a state $s$ and a tollerance $\beta_s$ we define an insertion or placement $p$ a tuple $(b, I)$ where $b$ is a bin and $I$ is a set of items that are going to be packed in $b$ such that, $I \subseteq s.U \land \exists z (z \in \mathbb{Z} \land \forall i ( i \in I \land |z_i - z| \le \beta_s))$
\end{definition}

\begin{observation}
    Given $s$ and $p = (b, \emptyset)$ where $b \notin s.B$, $p$ is an insertion which will open bin $b$ in $s$.
\end{observation}

\begin{definition}[Next]
    \label{def:state_next}%
    Let $p$ be an insertion over a state $s$ we can then define $s^\prime = Next(s, p)$ as the "copy" of state $s$ with $s^\prime.P = s.P \cup p$. $p$ is then pending on $s^\prime$.
\end{definition}

In this way we can evaluate the changes to the score of a state based on its pending insertion without having to update all the structures for every evaluated state. This property will become apparent in section \ref{sec:beamsearch}. 

We can then define an algorithm that applies insertions to a given state $s$ with pending insertions with the help of a function $OpenBin(b)$ which initializes a new structure $s_b$ with every element at its empty value.
The proposed algorithm is shown in \ref{algo:state_commit}.

\input{algorithms/state_commit}

\paragraph*{Insertion feasibility}
%TODO: Continue with definition of feasibility for sets already made and feasibility of an insertion

\paragraph*{State feasibility}
%TODO: Give a brief description on how to use the AABB to computer the feasibility of a given state instead

\begin{proposition}
    A state $s^\prime$ derived by committing a feasible insertion $P$ to a feasible state $s$ is feasible.
\end{proposition}

\begin{observation}
    \label{def:empty_state}
    We can always define the empty state $s_e$ where \begin{equation*}
        \left\{ 
            \begin{aligned}
            s_e.U & = I \\
            s_e.B & = \emptyset
            \end{aligned}
        \right.
    \end{equation*}
    and it is always feasible
\end{observation}

\section{Beam Search}
\label{sec:beamsearch}%
Beam Search (BS) %TODO: maybe add info on literature, define indices
is an heuristic graph search algorithm designed for systems with limited memory where expanding every possible node is unfeasible.
The idea behind BS is to conduct a iterative truncated breadth-first search where, at each iteration, expanded nodes are ranked based on an heuristic and only the best ones are further explored.
To perform BS one must define the node structure, an expansion function to generate new nodes from existing ones, a ranking between nodes and a function to determine if a node is final.

By using as node structure the state defined in \ref{sec:problem_state} and function \ref{algo:state_final} to define if a node is final we can define the next state $s^\prime$ starting from state $s$ as a new state .


Let $s_i$ be a node in the graph of possible solutions of the 3DBPP, %todo change to group by height
$s_i$ can be seen as an instance of the problem where a sequence of placements has taken place.
An expansion of a node $s_i$ generates a new node $s_j$ where a placement has occured for a given set of items.
Since evaluating possible expansions can be computationally easier than computing new node data structures, %TODO: Explain better
a $Commit$ function is defined which applies a pre-computed expansion by updating the supporting data structures in its node.

Given $S_{init}$ the set of initial nodes to start from and $k$ the number of best nodes to expand at each iteration, the described procedure is rappresented by algorithm \ref{algo:beamsearch}.

\input{algorithms/beamsearch}

The $Expand$ function computes new nodes which rappresent possible placements that can be made starting from a given packing.
Each node contains a number of supporting data structures that are updated across iterations by the $Commit$ function.

Let $S$ be the set of nodes that need to be expanded, each node $s$ is rappresented by a structure which contains
\begin{itemize}
    \item[--] $bins$: the set of open bins
    \item[--] $unpacked$: the set of items that aren't assigned to any bin
    \item[--] $s_b$: a substructure which cointains informations about a bin $b$
\end{itemize}
%TODO: espandere GroupByHeight
Let $GroupByHeight(I)$ be a function which operates on a set of items and outputs a set of tuples $(t, I)$ where $t$ is the family of the set $I$ of items. %TODO: Explain better
A new set of nodes can be computed by using an underlying 3DSPP heuristic which evaluates the best move for each family of items for each currently opened bin.
The described procedure is detailed in algorithm \ref{algo:state_successor}  

\input{algorithms/state_successor}

\subsection{Scoring States}
\label{ssec:scoring_states}%
In order to sort nodes, a scoring function needs to be defined over the nodes. 
To allow the BS to explore better solutions the scoring function can't be as flat as the objective function defined in the mathematical formulation of the problem. %TODO: aggiungere ref

\section{Support Planes}
\label{sec:support_planes}%
%TODO far scorrere meglio
We introduce Support Planes (SP) which is an heuristic introduced in this thesis based on an underlying 2DBPP heuristic which is used to evaluate feasible expansions of a given node in the BS.
The proposed heuristic ensures that the constraint of support isn't violated.
The idea at the base of SP is to build a solution to the 3DSPP by filling 2D planes called support planes.

Each support plane can be characterized by the triple $S_z = (z, I_{support}, I_{upper})$ where
\begin{itemize}
    \item[--] $z$: the height of the plane 
    \item[--] $I_{support}$: the set of the items that can offer support to items placed on the plane
    \item[--] $I_{upper}$: the set of items that will be obstacles to potential new items placed on the plane %TODO: change explaination to be more faithfull to the algorithm
\end{itemize}%TODO: link to support

Let $s_b$ be a data structure containing
%TODO: Weight? Forbidden Cuts?
\begin{itemize}
    \item[--] $planes$: the set of triples $S_z$ of support planes to evaluate, ordered in ascending $z$ order
    \item[--] $aabb$: the AABB Tree of the items placed in the evaluated bin
    \item[--] $(W_{b}, D_{b}, H_{b})$: the dimensions of the bin
\end{itemize}

Let $coords$ be the set of possible coordinate changes which allow for the problem to evaluate placements starting from different corners of the bin. %TODO: leave this here?
%TODO: Maybe explicit rotation?

Given a function $IsFeasible(i, bin, I_{support}, I_{upper}, aabb)$ which evaluates if a packing of item $i$ in bin $bin$ is feasible,
and the function $ComparePacking(p, p^\prime)$ which defines a ranking over placements in the same plane,
the SP algorithm can be written as algorithm \ref{algo:sp_bestinsertion}.
%TODO: Too many "let"?

\input{algorithms/supportplane}

To evaluate a packing on a plane an heuristic to solve the 2DBPP is used with the introduction of fixed placements which rappresent items on other planes that will be obstacles in the current one.

%TODO: Specify that the selected heuristic must operate with the assumption of fixed placements

Given the dimensions of the 2D bin $(W_b, D_b)$, the set of obstacles $I_{o}$ and the set of items to pack $I_{p}$ a new placement can be computed following algorithm \ref{algo:sp_rectpack}

\input{algorithms/sp_rectpack}

Once the $k$ best nodes are selected the placements evaluated for each node are applied and the $Commit$ function updates every datastructure in $S$, including the ones used by SP.
Given the instance that generated one of the placements selected and $p$ the current set of support planes, $z_{min}$ the minimum $z$ coordinate for which a placement was made in the related bin starting from the current state, $I$ the set of items placed, $U$ the set of items unpacked.
Since placements are evaluated in order starting from the lower $z$ possible, if no placement was made in an open support plane with $z$ lower than $z_{min}$, the plane can be pruned to avoid further evaluations.
The algorithm which updates the structures for a given SP instance is rappresent by algorithm \ref{algo:sp_commit}.

\input{algorithms/sp_commit}

\subsection{Scoring Insertions}
\label{ssec:scoring_insertions}%